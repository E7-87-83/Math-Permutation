.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Permutation 3"
.TH Math::Permutation 3 "2025-07-05" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Permutation \- pure Perl implementation of functions related to the permutations
.SH "VERSION"
.IX Header "VERSION"
Version 0.0211
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::Permutation;
\&
\&    my $foo = Math::Permutation\->cycles([[1,2,6,7], [3,4,5]]);
\&    say $foo\->sprint_wrepr;
\&    # "2,6,4,5,3,7,1"
\&    say join ",", $foo\->array;
\&    # 2,6,4,5,3,7,1
\&
\&    my $bar = Math::Permutation\->unrank(5, 19);
\&    say $bar\->sprint_cycles;
\&    # (2 5 4 3)
\&    # Note that there is no canonical cycle representation in this module,
\&    # so each time the output may be slightly different.
\&
\&    my $goo = Math::Permutation\->clone($foo);
\&    say $goo\->sprint_cycles;
\&    # (1 2 6 7) (4 5 3)
\&
\&    $foo\->inverse;
\&    say $foo\->sprint_cycles;
\&    # (4 3 5) (1 7 6 2)
\&
\&    $foo\->comp($goo);
\&    say $foo\->sprint_cycles;
\&    # ()
\&
\&    say $bar\->rank; # 19
\&    $bar\->prev;
\&    say $bar\->rank; # 18
\&    say $goo\->rank; # 1264
\&    $goo\->nxt;
\&    say $goo\->rank; # 1265
\&
\&    say $goo\->is_even; # 0
\&    say $goo\->sgn;     # \-1
\&
\&    use Data::Dump qw/dump/;
\&    say $bar\->sprint_wrepr;
\&    dump $bar\->matrix;
\&
\&    # "1,4,5,3,2"
\&    # [
\&    #   [1, 0, 0, 0, 0],
\&    #   [0, 0, 0, 0, 1],
\&    #   [0, 0, 0, 1, 0],
\&    #   [0, 1, 0, 0, 0],
\&    #   [0, 0, 1, 0, 0],
\&    # ]
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1INITALIZE/GENERATE NEW PERMUTATION\s0"
.IX Subsection "INITALIZE/GENERATE NEW PERMUTATION"
.ie n .IP "$p\->init($n)" 4
.el .IP "\f(CW$p\fR\->init($n)" 4
.IX Item "$p->init($n)"
Initialize \f(CW$p\fR with the identity permutation of \f(CW$n\fR elements.
.ie n .IP "$p\->wrepr([$a, $b, $c, ..., $m])" 4
.el .IP "\f(CW$p\fR\->wrepr([$a, \f(CW$b\fR, \f(CW$c\fR, ..., \f(CW$m\fR])" 4
.IX Item "$p->wrepr([$a, $b, $c, ..., $m])"
Initialize \f(CW$p\fR with word representation of a permutation, a.k.a. one-line form.
.ie n .IP "$p\->tabular([$a, $b, ... , $m], [$pa, $pb, $pc, ..., $pm])" 4
.el .IP "\f(CW$p\fR\->tabular([$a, \f(CW$b\fR, ... , \f(CW$m\fR], [$pa, \f(CW$pb\fR, \f(CW$pc\fR, ..., \f(CW$pm\fR])" 4
.IX Item "$p->tabular([$a, $b, ... , $m], [$pa, $pb, $pc, ..., $pm])"
Initialize \f(CW$p\fR with the rules of a permutation, with input of permutation on the first list,
the output of permutation. If the first list is [1..$n], it is often called two-line form,
and the second list would be the word representation.
.ie n .IP "$p\->cycles([[$a, $b, $c], [$d, $e], [$f, $g]])" 4
.el .IP "\f(CW$p\fR\->cycles([[$a, \f(CW$b\fR, \f(CW$c\fR], [$d, \f(CW$e\fR], [$f, \f(CW$g\fR]])" 4
.IX Item "$p->cycles([[$a, $b, $c], [$d, $e], [$f, $g]])"
.PD 0
.ie n .IP "$p\->cycles_with_len($n, [[$a, $b, $c], [$d, $e], [$f, $g]])" 4
.el .IP "\f(CW$p\fR\->cycles_with_len($n, [[$a, \f(CW$b\fR, \f(CW$c\fR], [$d, \f(CW$e\fR], [$f, \f(CW$g\fR]])" 4
.IX Item "$p->cycles_with_len($n, [[$a, $b, $c], [$d, $e], [$f, $g]])"
.PD
Initialize \f(CW$p\fR by the cycle notation. If the length is not specific, the length would be the largest element in the cycles.
.ie n .IP "$p\->unrank($n, $i)" 4
.el .IP "\f(CW$p\fR\->unrank($n, \f(CW$i\fR)" 4
.IX Item "$p->unrank($n, $i)"
Initialize \f(CW$p\fR referring to the lexicological rank of all \f(CW$n\fR\-permutations. \f(CW$i\fR must be between 1 and \f(CW$n\fR!.
.Sp
Note: The current version is not optimal. It is using an O(n^2) implementation, instead of the best O(n log n) implementation.
.ie n .IP "$p\->random($n)" 4
.el .IP "\f(CW$p\fR\->random($n)" 4
.IX Item "$p->random($n)"
Initialize \f(CW$p\fR by a randomly selected \f(CW$n\fR\-permutation.
.SS "\s-1DISPLAY THE PERMUTATION\s0"
.IX Subsection "DISPLAY THE PERMUTATION"
.ie n .IP "$p\->\fBarray()\fR" 4
.el .IP "\f(CW$p\fR\->\fBarray()\fR" 4
.IX Item "$p->array()"
Return an array showing the permutation.
.ie n .IP "$p\->\fBsprint_wrepr()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsprint_wrepr()\fR" 4
.IX Item "$p->sprint_wrepr()"
Return a string displaying the word representation of \f(CW$p\fR.
.ie n .IP "$p\->\fBsprint_tabular()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsprint_tabular()\fR" 4
.IX Item "$p->sprint_tabular()"
Return a two-line string displaying the tabular form of \f(CW$p\fR.
.ie n .IP "$p\->\fBsprint_cycles()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsprint_cycles()\fR" 4
.IX Item "$p->sprint_cycles()"
Return a string with cycles of \f(CW$p\fR. One-cycles are omitted.
.ie n .IP "$p\->\fBsprint_cycles_full()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsprint_cycles_full()\fR" 4
.IX Item "$p->sprint_cycles_full()"
Return a string with cycles of \f(CW$p\fR. One-cycles are included.
.SS "\s-1CHECK EQUIVALENCE BETWEEN PERMUTATIONS\s0"
.IX Subsection "CHECK EQUIVALENCE BETWEEN PERMUTATIONS"
.ie n .IP "$p\->eqv($q)" 4
.el .IP "\f(CW$p\fR\->eqv($q)" 4
.IX Item "$p->eqv($q)"
Check if the permutation \f(CW$q\fR is equivalent to \f(CW$p\fR. Return 1 if yes, 0 otherwise.
.SS "\s-1CLONE THE PERMUTATION\s0"
.IX Subsection "CLONE THE PERMUTATION"
.ie n .IP "$p\->clone($q)" 4
.el .IP "\f(CW$p\fR\->clone($q)" 4
.IX Item "$p->clone($q)"
Clone the permutation \f(CW$q\fR into \f(CW$p\fR.
.SS "\s-1MODIFY THE PERMUTATION\s0"
.IX Subsection "MODIFY THE PERMUTATION"
.ie n .IP "$p\->swap($i, $j)" 4
.el .IP "\f(CW$p\fR\->swap($i, \f(CW$j\fR)" 4
.IX Item "$p->swap($i, $j)"
Swap the values of \f(CW$i\fR\-th position and \f(CW$j\fR\-th position.
.ie n .IP "$p\->comp($q)" 4
.el .IP "\f(CW$p\fR\->comp($q)" 4
.IX Item "$p->comp($q)"
Composition of \f(CW$p\fR and \f(CW$q\fR, sometimes called multiplication of the permutations. 
The resultant is \f(CW$q\fR \f(CW$p\fR (first do \f(CW$p\fR, then do \f(CW$q\fR).
.Sp
\&\f(CW$p\fR and \f(CW$q\fR must be permutations of same number of elements.
.ie n .IP "$p\->\fBinverse()\fR" 4
.el .IP "\f(CW$p\fR\->\fBinverse()\fR" 4
.IX Item "$p->inverse()"
Inverse of \f(CW$p\fR.
.ie n .IP "$p\->\fBnxt()\fR" 4
.el .IP "\f(CW$p\fR\->\fBnxt()\fR" 4
.IX Item "$p->nxt()"
The next permutation under the lexicological order of all \f(CW$n\fR\-permutations.
.Sp
Caveat: may return [].
.ie n .IP "$p\->\fBprev()\fR" 4
.el .IP "\f(CW$p\fR\->\fBprev()\fR" 4
.IX Item "$p->prev()"
The previous permutation under the lexicological order of all \f(CW$n\fR\-permutations.
.Sp
Caveat: may return [].
.SS "\s-1PRORERTIES OF THE CURRENT PERMUTATION\s0"
.IX Subsection "PRORERTIES OF THE CURRENT PERMUTATION"
.ie n .IP "$p\->sigma($i)" 4
.el .IP "\f(CW$p\fR\->sigma($i)" 4
.IX Item "$p->sigma($i)"
Return what \f(CW$i\fR is mapped to under \f(CW$p\fR.
.ie n .IP "$p\->\fBrule()\fR" 4
.el .IP "\f(CW$p\fR\->\fBrule()\fR" 4
.IX Item "$p->rule()"
Return the word representation of \f(CW$p\fR as a list.
.ie n .IP "$p\->\fBcyc()\fR" 4
.el .IP "\f(CW$p\fR\->\fBcyc()\fR" 4
.IX Item "$p->cyc()"
Return the cycle representation of \f(CW$p\fR as a list of list(s).
.ie n .IP "$p\->\fBelems()\fR" 4
.el .IP "\f(CW$p\fR\->\fBelems()\fR" 4
.IX Item "$p->elems()"
Return the length of \f(CW$p\fR.
.ie n .IP "$p\->\fBrank()\fR" 4
.el .IP "\f(CW$p\fR\->\fBrank()\fR" 4
.IX Item "$p->rank()"
Return the lexicological rank of \f(CW$p\fR. See \f(CW$p\fR\->unrank($n, \f(CW$i\fR).
.Sp
Note: The current version is not optimal. It is using an O(n^2) implementation, instead of the best O(n log n) implementation.
.ie n .IP "$p\->\fBindex()\fR" 4
.el .IP "\f(CW$p\fR\->\fBindex()\fR" 4
.IX Item "$p->index()"
Return the permutation index of \f(CW$p\fR.
.ie n .IP "$p\->\fBorder()\fR" 4
.el .IP "\f(CW$p\fR\->\fBorder()\fR" 4
.IX Item "$p->order()"
Return the order of \f(CW$p\fR, i.e. how many times the permutation acts on itself
and return the identity permutation.
.ie n .IP "$p\->\fBis_even()\fR" 4
.el .IP "\f(CW$p\fR\->\fBis_even()\fR" 4
.IX Item "$p->is_even()"
Return whether \f(CW$p\fR is an even permutation. Return 1 or 0.
.ie n .IP "$p\->\fBis_odd()\fR" 4
.el .IP "\f(CW$p\fR\->\fBis_odd()\fR" 4
.IX Item "$p->is_odd()"
Return whether \f(CW$p\fR is an odd permutation. Return 1 or 0.
.ie n .IP "$p\->\fBsgn()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsgn()\fR" 4
.IX Item "$p->sgn()"
Return the signature of \f(CW$p\fR. Return +1 if \f(CW$p\fR is even, \-1 if \f(CW$p\fR is odd.
.Sp
Another view is the determinant of the permutation matrix of \f(CW$p\fR.
.ie n .IP "$p\->\fBinversion()\fR" 4
.el .IP "\f(CW$p\fR\->\fBinversion()\fR" 4
.IX Item "$p->inversion()"
Return the inversion sequence of \f(CW$p\fR as a list.
.ie n .IP "$p\->\fBmatrix()\fR" 4
.el .IP "\f(CW$p\fR\->\fBmatrix()\fR" 4
.IX Item "$p->matrix()"
Return the permutation matrix of \f(CW$p\fR.
.ie n .IP "$p\->\fBfixed_points()\fR" 4
.el .IP "\f(CW$p\fR\->\fBfixed_points()\fR" 4
.IX Item "$p->fixed_points()"
Return the list of fixed points of \f(CW$p\fR.
.ie n .IP "$p\->\fBsqrt()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsqrt()\fR" 4
.IX Item "$p->sqrt()"
Caveat: may return undef.
.SH "METHODS TO BE INPLEMENTED"
.IX Header "METHODS TO BE INPLEMENTED"
.IP "\fBlongest_increasing()\fR" 4
.IX Item "longest_increasing()"
.PD 0
.IP "\fBlongest_decreasing()\fR" 4
.IX Item "longest_decreasing()"
.IP "\fBcoxeter_decomposition()\fR" 4
.IX Item "coxeter_decomposition()"
.IP "comp( more than one permutations )" 4
.IX Item "comp( more than one permutations )"
.IP "\fBreverse()\fR" 4
.IX Item "reverse()"
.PD
ref: Chapter 1, Patterns in Permutations and Words
.IP "\fBcomplement()\fR" 4
.IX Item "complement()"
ref: Chapter 1, Patterns in Permutations and Words
.IP "\fBis_irreducible()\fR" 4
.IX Item "is_irreducible()"
ref: Chapter 1, Patterns in Permutations and Words
.IP "\fBnum_of_occurrences_of_pattern()\fR" 4
.IX Item "num_of_occurrences_of_pattern()"
ref: Chapter 1, Patterns in Permutations and Words
.IP "\fBcontains_pattern()\fR" 4
.IX Item "contains_pattern()"
ref: Chapter 1, Patterns in Permutations and Words
.IP "\fBavoids_pattern()\fR" 4
.IX Item "avoids_pattern()"
ref: Chapter 1, Patterns in Permutations and Words
.Sp
including barred patterns
.Sp
ref: Section 1.2, Patterns in Permutations and Words
.Sp
Example: [ \-3, \-1, 5, \-2, 4 ]
.SH "AUTHOR"
.IX Header "AUTHOR"
Cheok-Yin Fung, \f(CW\*(C`<fungcheokyin at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to <https://github.com/E7\-87\-83/Math\-Permutation/issues>.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Math::Permutation
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<https://rt.cpan.org/NoAuth/Bugs.html?Dist=Math\-Permutation>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<https://metacpan.org/release/Math\-Permutation>
.SH "REFERENCES"
.IX Header "REFERENCES"
The module has gained ideas from various sources:
.PP
Opensource resources:
.IP "\(bu" 4
Julia Package Permutations.jl <https://github.com/scheinerman/Permutations.jl/blob/master/docs/src/index.md>
.IP "\(bu" 4
\&\s-1CPAN\s0 Module Math::GSL::Permutation <https://metacpan.org/pod/Math::GSL::Permutation>
.IP "\(bu" 4
Combinatorics features of Maxima <https://maxima.sourceforge.io/docs/manual/maxima_singlepage.html#combinatorics_002dpkg>
.PP
General resources:
.IP "\(bu" 4
Wolfram Alpha <https://www.wolframalpha.com/>
.IP "\(bu" 4
\&\fIAlgebra\fR, Michael Artin
.IP "\(bu" 4
\&\fIPatterns in Permutations and Words\fR, Sergey Kitaev
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This software is Copyright (c) 2022\-2025 by Cheok-Yin Fung.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  MIT License
.Ve
